import { GoogleGenAI } from "@google/genai";

// Helpers to process Base64
const extractBase64 = (dataUrl: string): string => {
  return dataUrl.split(',')[1];
};

const getMimeType = (dataUrl: string): string => {
  return dataUrl.split(';')[0].split(':')[1];
};

const extractImageFromResponse = (response: any): string => {
  const parts = response.candidates?.[0]?.content?.parts || [];
  
  for (const part of parts) {
    if (part.inlineData) {
      return `data:image/png;base64,${part.inlineData.data}`;
    }
  }

  // If we get here, no image was found. Check for text explaining why.
  const textPart = parts.find((p: any) => p.text);
  if (textPart && textPart.text) {
    // Clean up the error message if it's a model refusal
    const msg = textPart.text.length > 200 ? textPart.text.substring(0, 200) + "..." : textPart.text;
    throw new Error(`Model returned text: "${msg}"`);
  }

  throw new Error("No image generated by the model.");
};

/**
 * Helper to attempt generation with a primary model and fallback to a secondary model
 * if a permission or access error occurs.
 */
async function generateWithFallback(
  primaryModel: string,
  fallbackModel: string,
  contents: any,
  primaryConfig?: any,
  fallbackConfig?: any
) {
  const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
  
  try {
    const response = await ai.models.generateContent({
      model: primaryModel,
      contents,
      config: primaryConfig
    });
    return response;
  } catch (error: any) {
    const msg = error.toString().toLowerCase();
    // Check for Permission Denied (403), Not Found (404), or other access issues
    // Sometimes 400 is returned if the model is not compatible with the key's tier features
    if (msg.includes('403') || msg.includes('permission') || msg.includes('not found') || msg.includes('404')) {
      console.warn(`Primary model ${primaryModel} failed. Falling back to ${fallbackModel}. Error: ${msg}`);
      return await ai.models.generateContent({
        model: fallbackModel,
        contents,
        config: fallbackConfig
      });
    }
    // If it's another type of error (e.g., server error), rethrow it.
    throw error;
  }
}

/**
 * Module 1: Transform a picture of a place into its ancient self.
 * Primary: 'gemini-3-pro-image-preview' (Best quality)
 * Fallback: 'gemini-2.5-flash-image' (Standard quality)
 */
export const restoreAncientPlace = async (imageDataUrl: string, context: string = ""): Promise<string> => {
  const base64Data = extractBase64(imageDataUrl);
  const mimeType = getMimeType(imageDataUrl);

  const contextInstruction = context 
    ? `HISTORICAL CONTEXT PROVIDED BY ARCHAEOLOGIST: "${context}". Use this style/era specifically.` 
    : "CONTEXT: Infer the civilization and era from the visual architectural clues in the ruins.";

  const contents = {
    parts: [
      {
        text: "ROLE: You are a visionary architect specializing in historical reconstruction.\n" +
              "TASK: Rebuild the structure in the image. Do not just edit the photo; you must REDRAW the scene as it looked when it was BRAND NEW.\n\n" +
              `${contextInstruction}\n\n` +
              "STRICT RECONSTRUCTION RULES:\n" +
              "1. IGNORE CURRENT DAMAGE: Treat the input image ONLY as a layout reference. Overwrite every single ruin, broken stone, and crumbled wall with pristine, complete architecture.\n" +
              "2. STRUCTURAL COMPLETION: If a roof is missing, YOU MUST ADD A ROOF. If a wall is half-height, EXTEND IT TO FULL HEIGHT. If columns are broken, MAKE THEM WHOLE and identical.\n" +
              "3. MATERIAL RESTORATION: Change the texture from 'weathered ruin' to 'freshly built'. Marble should be white and polished. Wood should be painted or fresh. \n" +
              "4. ENVIRONMENT: Remove all modern walkways, tourists, signs, and electric lights. Replace them with period-accurate ground (dirt, paving stones) and ancient people.\n" +
              "5. AGGRESSIVENESS: High. The goal is to show the building *before* it became a ruin. It should look like a functional building, not an archaeological site."
      },
      {
        inlineData: {
          data: base64Data,
          mimeType: mimeType
        }
      }
    ]
  };

  const response = await generateWithFallback(
    'gemini-3-pro-image-preview',
    'gemini-2.5-flash-image',
    contents,
    { imageConfig: { imageSize: "1K" } },
    {} // Flash image usually infers config or uses defaults
  );

  return extractImageFromResponse(response);
};

/**
 * Module 2: Read and translate ancient texts.
 * Primary: 'gemini-3-pro-preview' (Best reasoning)
 * Fallback: 'gemini-2.5-flash' (Fast reasoning)
 */
export const translateAncientText = async (imageDataUrl: string, targetLanguage: string = 'English'): Promise<string> => {
  const base64Data = extractBase64(imageDataUrl);
  const mimeType = getMimeType(imageDataUrl);

  const contents = {
    parts: [
      {
        text: "Analyze the image provided which contains ancient text. \n" +
              "1. Identify the language/script.\n" +
              "2. Transcribe the text exactly as seen.\n" +
              `3. Translate the text into ${targetLanguage}.\n` +
              `4. Provide a brief historical context (write this explanation in ${targetLanguage}).\n` +
              "Format the output clearly in Markdown.",
      },
      {
        inlineData: {
          data: base64Data,
          mimeType: mimeType
        }
      }
    ]
  };

  const response = await generateWithFallback(
    'gemini-3-pro-preview',
    'gemini-2.5-flash',
    contents
  );

  if (response.text) {
    return response.text;
  }
  
  throw new Error("No translation could be generated.");
};

/**
 * Module 3: Complete ancient mosaics.
 * Primary: 'gemini-3-pro-image-preview' (Best coherence)
 * Fallback: 'gemini-2.5-flash-image' (Standard coherence)
 */
export const completeMosaic = async (imageDataUrl: string, context: string = ""): Promise<string> => {
  const base64Data = extractBase64(imageDataUrl);
  const mimeType = getMimeType(imageDataUrl);

  const contextInstruction = context
    ? `HISTORICAL/ARTISTIC CONTEXT: "${context}". Use this specific style, era, or subject matter for the reconstruction.`
    : "CONTEXT: Infer the style and subject from the remaining fragments.";

  const contents = {
    parts: [
      {
        text: "ROLE: You are a master mosaic restoration AI.\n" +
              "TASK: The input image is a DAMAGED FRAGMENT of a larger mosaic. You must generate a FULL-FRAME RESTORATION.\n\n" +
              `${contextInstruction}\n\n` +
              "CRITICAL FIXES REQUIRED:\n" +
              "1. **RESTORE THE CENTRAL FIGURE**: The center is the most important part. It is currently damaged or missing. You MUST reconstruct the main character, animal, or object that belongs in the center. Do not leave it as just background pattern.\n" +
              "2. **RECONSTRUCT ANATOMY**: If there are figures, ensure they have complete heads, limbs, and faces. Repair any obliterated features with high detail.\n" +
              "3. **FILL THE ENTIRE IMAGE**: The output must be a complete rectangle. Extend borders and background patterns all the way to the edges.\n" +
              "4. **UNIFY THE STYLE**: Ensure the new tiles perfectly match the color and size of the old tiles.\n" +
              "5. **BOLD RECONSTRUCTION**: Be creative and bold. Do not be conservative. A complete guess at the missing figure is better than a hole.",
      },
      {
        inlineData: {
          data: base64Data,
          mimeType: mimeType
        }
      }
    ]
  };

  const response = await generateWithFallback(
    'gemini-3-pro-image-preview',
    'gemini-2.5-flash-image',
    contents,
    { imageConfig: { imageSize: "1K" } },
    {}
  );

  return extractImageFromResponse(response);
};

/**
 * Module 4: Restore destroyed vases/pottery.
 * Primary: 'gemini-3-pro-image-preview' (Nano Banana Pro)
 * Fallback: 'gemini-2.5-flash-image'
 */
export const restoreVase = async (imageDataUrl: string, context: string = ""): Promise<string> => {
  const base64Data = extractBase64(imageDataUrl);
  const mimeType = getMimeType(imageDataUrl);

  const contextInstruction = context
    ? `ARTIFACT DETAILS: "${context}". Use this style (e.g. Ming, Greek Geometric, Mayan) to guide the pattern reconstruction.`
    : "CONTEXT: Identify the pottery style (e.g., Greek, Chinese, Pre-Columbian) from the shards and restore accordingly.";

  const contents = {
    parts: [
      {
        text: "ROLE: You are an expert museum conservator specializing in ceramics and pottery.\n" +
              "TASK: Digitally reconstruct the broken vase/vessel in the image into its original, pristine condition.\n\n" +
              `${contextInstruction}\n\n` +
              "RESTORATION STEPS:\n" +
              "1. **SHAPE RECOVERY**: Extrapolate the curves of the existing shards to infer the full 3D silhouette of the vase (amphora, bowl, vase, etc.). Complete the rim, neck, body, and base.\n" +
              "2. **CRACK FILLING**: Seamlessly heal all cracks, fissures, and missing chunks. The surface should look smooth and unbroken, as if it just came out of the kiln.\n" +
              "3. **PATTERN CONTINUATION**: Analyze the painted motifs on the shards. Mathematically extend these patterns across the reconstructed areas to complete the scene or design.\n" +
              "4. **LIGHTING & MATERIAL**: Maintain the glossy or matte finish of the original material (clay, porcelain, terracotta). Ensure lighting highlights are consistent across the new parts.\n" +
              "5. **OUTPUT**: The result should be a photo-realistic, whole vase standing on a neutral surface.",
      },
      {
        inlineData: {
          data: base64Data,
          mimeType: mimeType
        }
      }
    ]
  };

  const response = await generateWithFallback(
    'gemini-3-pro-image-preview',
    'gemini-2.5-flash-image',
    contents,
    { imageConfig: { imageSize: "1K" } },
    {}
  );

  return extractImageFromResponse(response);
};